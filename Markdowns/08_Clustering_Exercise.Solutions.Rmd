---
title: "Introduction to single-cell RNA-seq analysis"
author: "Ashley Sawle"
date: "April 2024"
subtitle: Clustering and Marker Genes - Exercise (one possible) solution
output:
  html_document:
    toc: yes
    toc_depth: 2
---

```{r setup, warning=FALSE, message=FALSE, include=FALSE}
library(scater) # scRnaSeq QC
library(scran) # scRnaSeq normalisation
library(bluster) # scRnaSeq clustering
library(cluster) # for silhouette
library(igraph) # for graph-based clustering and plotting networks
library(pheatmap) # for heatmap plotting
library(patchwork) # to combine plots
library(tidyverse) # data wrangling and plotting (ggplot2)
library(DT) # for printing nice data tables from data.frames

knitr::opts_chunk$set(cache=FALSE) # This prevents RStudio from caching the results when you render the report
```

# Load data

Cluster sweep has already been run on the QC'd, filtered, normalised and batch
corrected Caron data. Please see the script *ClusterSweep.R* for details.

Here the `clusterSweep` results object, cluster behaviour metrics and the SCE
object containing corrected data and the clusters are loaded.

```{r load_data}
out <- readRDS("R_objects/clusterSweep.out.rds")
df <- read_tsv("R_objects/clusterSweep.metrics_df.tsv", 
               show_col_types = FALSE)
sce <- readRDS("R_objects/clusterSweep.sce.rds")
```

Cluster sweep was run with the following combinations of parameters:

```{r tableOfparameters}
out$parameters %>%
  as.data.frame() %>% 
  select(`Cluster function`=cluster.fun, k) %>% 
  rownames_to_column("colData column") %>% 
  datatable(rownames=FALSE)
```

# Assess cluster behaviour metrics

We will consider the number of clusters, the mean silhouette width and the sum
of the within-cluster sum of squares as an initial assessment of cluster
behaviour. To assess the behaviour of the clusterings we can plot these metrics
against the *k*.

```{r plotMetrics, fig.width=12}
nclPlot <- ggplot(df, aes(x = k, y = num.clusters)) + 
                geom_line(aes(colour=cluster.fun), lwd=2) +
                ylim(c(0, 75))

silPlot <- ggplot(df, aes(x = k, y = silhouette)) + 
                geom_line(aes(colour=cluster.fun), lwd=2)

wcssPlot <- ggplot(df, aes(x = k, y = wcss)) + 
                geom_line(aes(colour=cluster.fun))

nclPlot + silPlot + wcssPlot + plot_layout(guides = "collect")
```

```{r}
df %>%
  filter(num.clusters>=10 & num.clusters<=15)
```



# Visualise the clusters using UMAP plots

I am going to be plotting the UMAP a lot, but I want to plot the UMAP generated from the 
batch corrected values - "UMAP_corrected". So that I can use `plotUMAP` instead of having
to use `plotReducedDim(sce, dimred = "UMAP_corrected", ...)`, I will first rename the reduced dimensions slots.

```{r}
reducedDim(sce, "UMAP_uncorrected") <- reducedDim(sce, "UMAP")
reducedDim(sce, "UMAP") <- reducedDim(sce, "UMAP_corrected")
```

We can now visualise our selected clusterings of interest on tSNE plots.

```{r}
plotUMAP(sce, colour_by = "k.60_cluster.fun.leiden")
plotUMAP(sce, colour_by = "k.70_cluster.fun.leiden")
plotUMAP(sce, colour_by = "k.20_cluster.fun.louvain")
plotUMAP(sce, colour_by = "k.30_cluster.fun.louvain")
```

```{r}
table(sce$k.60_cluster.fun.leiden)
table(sce$k.70_cluster.fun.leiden)
table(sce$k.20_cluster.fun.louvain)
table(sce$k.30_cluster.fun.louvain)
```
# Cluster-wise silhouette widths

```{r} 
plotSilhouette <- function(clusters, plotTitle){
  silTab <- approxSilhouette(reducedDim(sce, "corrected"), 
                                clusters=clusters) %>% 
    as.data.frame() %>% 
    mutate(closestCluster = ifelse(width > 0, cluster, other) %>% 
             factor())
  
  plt <- ggplot(silTab, aes(x=cluster, y=width, colour=closestCluster)) +
    ggbeeswarm::geom_quasirandom(method="smiley") +
    ggtitle(plotTitle)
  
  plt <- scater:::.resolve_plot_colours(plt, 
                                        silTab$closestCluster, 
                                        "closestCluster", 
                                        colour=TRUE)
  plt
}
```

## Leiden k = 60

```{r}
plotSilhouette(sce$k.60_cluster.fun.leiden, "Leiden k=60")
plotSilhouette(sce$k.70_cluster.fun.leiden, "Leiden k=70")
plotSilhouette(sce$k.20_cluster.fun.louvain, "Louvain k=20")
plotSilhouette(sce$k.30_cluster.fun.louvain, "Louvain k=30")
```


# B Cell marker genes

```{r}
rownames(sce) <- uniquifyFeatureNames(rowData(sce)$ID, rowData(sce)$Symbol)
```

```{r fig.height=12, fig.width=14}
p1 <- plotUMAP(sce, 
               by_exprs_values = "logcounts",
               colour_by = "MS4A1",
               text_by = "k.60_cluster.fun.leiden")
p2 <- plotUMAP(sce, 
               by_exprs_values = "logcounts", 
               colour_by = "CD79A",
               text_by = "k.60_cluster.fun.leiden")
p3 <- plotUMAP(sce, 
               by_exprs_values = "logcounts",
               colour_by = "TNFRSF13C",
               text_by = "k.60_cluster.fun.leiden")
p4 <- plotUMAP(sce, by_exprs_values = "logcounts", 
               colour_by = "BCL6",
               text_by = "k.60_cluster.fun.leiden")
(p1 + p2) / (p3 + p4)
```

# A look at the three louvain clusterings with Cluster Tree

We can look at how cells move between clusters using `clustree`

```{r}
combined <- cbind(k.60=sce$k.60_cluster.fun.leiden,
                  k.70=sce$k.70_cluster.fun.leiden,
                  k.80=sce$k.80_cluster.fun.leiden)

library(clustree)
set.seed(1111)
clustree(combined, prefix="k.", edge_arrow=FALSE)
```

# Comparing two sets of clusters

```{r fig.width=6, fig.height=4}
jacc.mat <- linkClustersMatrix(sce$k.20_cluster.fun.louvain, sce$k.60_cluster.fun.leiden)
rownames(jacc.mat) <- paste("Louvain", rownames(jacc.mat))
colnames(jacc.mat) <- paste("Leiden", colnames(jacc.mat))
pheatmap(jacc.mat, color=viridis::viridis(100), cluster_cols=FALSE, cluster_rows=FALSE)
```

## Higher resolution with k

From this Leiden with k of 60-70 looks reasonable. Let's try k between 61 and 69.

```{r, fig.width=14, fig.height=6}
p1 <- plotUMAP(sce, 
         colour_by = "k.60_cluster.fun.leiden",
         text_by = "k.60_cluster.fun.leiden")

p2 <- plotSilhouette(sce$k.60_cluster.fun.leiden, "Leiden k=60")

p1 + p2
```

```{r, eval=FALSE}
out.leiden <- clusterSweep(reducedDim(sce, "corrected"),
                    BLUSPARAM = NNGraphParam(),
                    k = as.integer(61:69),
                    cluster.fun = "leiden",
                    BPPARAM=BiocParallel::MulticoreParam(5))
saveRDS(out.leiden, "R_objects/clusterSweep.out.leiden.rds")
```

```{r}
out.leiden <- readRDS("R_objects/clusterSweep.out.leiden.rds")
```

Add the new clusters to the single cell experiment object.

```{r}
colData(sce) <- cbind(colData(sce), DataFrame(out.leiden$clusters))
```

Now let's compare some of the new clusterings.

```{r, fig.width = 14, fig.height = 16}
u1 <- plotUMAP(sce, colour_by = "k.60_cluster.fun.leiden")
s1 <- plotSilhouette(sce$k.60_cluster.fun.leiden, "Leiden k=60")
u2 <- plotUMAP(sce, colour_by = "k.64_cluster.fun.leiden")
s2 <- plotSilhouette(sce$k.64_cluster.fun.leiden, "Leiden k=64")
u3 <- plotUMAP(sce, colour_by = "k.68_cluster.fun.leiden")
s3 <- plotSilhouette(sce$k.68_cluster.fun.leiden, "Leiden k=68")
u4 <- plotUMAP(sce, colour_by = "k.70_cluster.fun.leiden")
s4 <- plotSilhouette(sce$k.70_cluster.fun.leiden, "Leiden k=70")

(u1 + s1) / (u2 + s2) / (u3 + s3) / (u4 + s4)
```

I am going to move forward with Leiden & k=64 for now.


```{r}
colLabels(sce) <- sce$k.64_cluster.fun.leiden
```

# Cluster marker gene detection

Add the clusters and then run `scoreMarkers`.

```{r}
markers <- scoreMarkers(sce, 
                        groups = factor(sce$label), 
                        block = sce$SampleName)
```

I asked you to identify this cluster:


```{r, echo=FALSE, out.width='60%', fig.align='center'}
knitr::include_graphics("Images/Clustering_Exercise_UMAP_highlight.png")
```

Which is made up of clusters 3 and 8.

```{r}
plotUMAP(sce, colour_by = "label", text_by = "label")
```

Let's have a look at the top marker genes for cluster 3:

```{r}
topRanked <- markers[["3"]] %>%
  as.data.frame() %>% 
  select(contains("cohen")) %>% 
  filter(rank.logFC.cohen <= 5) %>% 
  arrange(desc(mean.logFC.cohen))
topRanked
```

There's lots of ribosomal genes at the top of this list. Let's check the
expression of a few:

```{r}
plotExpression(sce, features = "RPS27", x = "label")
plotExpression(sce, features = "RPL34", x = "label")
plotExpression(sce, features = "RPL21", x = "label")
```

These aren't really going to be useful as marker genes.

On the other hand, further down we do have **CD3D**, **CD3E** and **TRAC**,
which are T-cell markers, and **IL32**, which is an indicator of T-cell
activation.

Let's take a look at these:

```{r fig.height=12, fig.width=14}
p1 <- plotUMAP(sce, colour_by = "CD3D", text_by = "label")
p2 <- plotUMAP(sce, colour_by = "CD3E", text_by = "label")
p3 <- plotUMAP(sce, colour_by = "TRAC", text_by = "label")
p4 <- plotUMAP(sce, colour_by = "IL32", text_by = "label")
(p1 + p2) / (p3 + p4) 
```

```{r fig.height=8, fig.width=14}
p1 <- plotExpression(sce, features = "CD3D", x = "label")
p2 <- plotExpression(sce, features = "CD3E", x = "label")
p3 <- plotExpression(sce, features = "TRAC", x = "label")
p4 <- plotExpression(sce, features = "IL32", x = "label")
(p1 + p2) / (p3 + p4) 
```

Let's take look at cluster 8's marker genes.

```{r}
topRanked <- markers[["8"]] %>%
  as.data.frame() %>% 
  select(contains("cohen")) %>% 
  filter(rank.logFC.cohen <= 5) %>% 
  arrange(desc(mean.logFC.cohen))
topRanked
```

**IL32**, **NKG7**, **GZMA** and **CD69** might suggest that these are activated
T-cells.

```{r fig.height=12, fig.width=14}
p1 <- plotUMAP(sce, colour_by = "IL32", text_by = "label")
p2 <- plotUMAP(sce, colour_by = "NKG7", text_by = "label")
p3 <- plotUMAP(sce, colour_by = "GZMA", text_by = "label")
p4 <- plotUMAP(sce, colour_by = "CD69", text_by = "label")
(p1 + p2) / (p3 + p4)
```

## Session information

<details>
```{r}
sessionInfo()
```
</details>
